#!/bin/bash
##################################################################
#
#  This file is part of M3C
#  Copyright (C) by authors (2012-2015)
#  
#  Authors:
#    * Dr. Néstor F. Aguirre (2012-2015)
#          nestor.aguirre@uam.es
#    * Dr. Sergio Díaz-Tendero (2012-2015)
#          sergio.diaztendero@uam.es
#    * Prof. M. Paul-Antoine Hervieux (2012-2015)
#          Paul-Antoine.Hervieux@ipcms.unistra.fr
#    * Prof. Fernando Martín (2012-2015)
#          fernando.martin@uam.es
#    * Prof. Manuel Alcamí (2012-2015)
#          manuel.alcami@uam.es
#  
#  Redistribution and use in source and binary forms, with or
#  without modification, are permitted provided that the
#  following conditions are met:
#  
#   * Redistributions of binary or source code must retain
#     the above copyright notice and this list of conditions
#     and/or other materials provided with the distribution.
#   * All advertising materials mentioning features or use of
#     this software must display the following acknowledgement:
#     
#     This product includes software from M3C project.
#
##################################################################

input=$1  # example: 3:H,C,F

echo $input | \
gawk '
	BEGIN{
		RS=","
		i=1
	}
	
	{
		number[i]=gensub("[[:alpha:]]+","","g",$1)
		if( number[i] == "" ) number[i]=1
		
		symbol[i]=gensub("[[:digit:]]+","","g",$1)
		i++
	}
	
	# Combination of n elements in groups of r elements
	function comb( n, r,    i, A, p, output ){
		output = ""
		
		for ( i=1; i <= r; i++ ) {
			## First combination of items:
			A[i] = i
			
			if ( i < r )
				output = output i OFS
			else
				output = output i ORS
		}
	
		## While 1st item is less than its maximum permitted value...
		while ( A[1] < n - r + 1 ) {
			## loop backwards through all items in the previous
			## combination of items until an item is found that is
			## less than its maximum permitted value:
			for (i = r; i >= 1; i--) {
				## If the equivalently positioned item in the
				## previous combination of items is less than its
				## maximum permitted value...
				if (A[i] < n - r + i) {
					## increment the current item by 1:
					A[i]++
					## Save the current position-index for use
					## outside this "for" loop:
					p = i
					break
				}
			}
			
			## Put consecutive numbers in the remainder of the array,
			## counting up from position-index p.
			for (i = p + 1; i <= r; i++)
				A[i] = A[i - 1] + 1
	
			## Print the current combination of items:
			for (i=1; i <= r; i++) {
				if (i < r)
					output = output A[i] OFS
				else
					output = output A[i] ORS
			}
		}
		
		return output
	}
	
	END{
		n=i-1
		
# 		print "------"
		
		k=1
		for(i=1;i<=n;i++){
			for( j=1; j<=number[i]; j++ ){
# 				print k, number[i], symbol[i]
				symbolList[k] = symbol[i]
				k++
			}
		}
		
		n = k-1
		
		for( i=1; i<=n; i++ ){
			values = comb( n, i )
			
			for( j=1; j<=n; j++ ){
				gsub( ""j"", symbolList[j], values )
			}
			gsub( " ", "+", values )
			
			gsub( " ", "", values )
			print values
		}

	}
' | \
gawk '
	( $1 !~ /^[[:blank:]]*$/ ){
		item = $1
		
		isInMap = ( item in map )
		
		if( isInMap == 0 )
			print item
		
		map[item] = 1
	}
' |
gawk '
BEGIN{
	first = 0
}
{
	if( first != 0 )
# 		printf ", "
		printf "\n"
	
	split($1,arr,"+")
	n = asort(keys)
	
	clabel = arr[1]
	
	n = 0
	for( i=1; i<=length(arr); i++ ){
		if( arr[i] != clabel ){
# 			if(n>1) printf clabel"_"n
			if(n>1) printf clabel""n
			else printf clabel
			
			n=0
			clabel = arr[i]
		}
		
		if( i == length(arr) ){
			if(n==0) n=1
			else n++
			
# 			if(n>1) printf clabel"_"n
			if(n>1) printf clabel""n
			else printf clabel
		}
		
		
		n++
	}
	
	first = 1
}
END{
	print ""
}
'
